import validationRules from "./rules.json";

/**
 * Middleware that checks the request body and querystring against the
 * existing json configuration in order to ensure that:
 * all required parameters are present
 * all parameters are of the correct type
 * non-existing parameters are blocked
 *
 * @throws throw a 400 code error with a relevant error message
 *
 * @param {object} req request object generated by express
 * @param {object} res response object generated by express
 * @param {function} next middleware function
 */
export const checkAgainstRules = (req, res, next) => {
  const rule = findValidationRules(req);

  if (!rule) {
    return next();
  }

  try {
    const { errors } = new RequestValidator(req, rule).validate();

    if (errors.length === 0) {
      return next();
    } else {
      res.status(400).send({ errors });
    }
  } catch (e) {
    res.status(500).send({ errors: [e.message] });
  }
};

/**
 * Find relevant validation rules for the current request
 * @param {object} req
 */
function findValidationRules(req) {
  const match = validationRules.paths[req.path];
  return match ? Object.values(match)[0] : null;
}

/**
 * Request validator which takes a request and related rules to validate provided parameters from either query string or request body.
 * If properties do not meet the validation rules, errors are logged and a validation result is returned from the `validate()` function.
 */
export class RequestValidator {
  errors = [];

  constructor(req, rule) {
    this.req = req;
    this.rule = rule;
  }

  validate() {
    const { body, query } = this.req;
    const ruleParameters = this.rule.parameters || [];

    // Loop through all parameter rules and validate provided values
    for (let paramRule of ruleParameters) {
      if (paramRule.in === "query") {
        this.validateQueryParameter(paramRule, query);
      } else if (paramRule.in === "body") {
        this.validateBodyParameter(paramRule, body);
      }
    }

    // Validate unexpected query params
    for (let name of Object.keys(query)) {
      const exists = ruleParameters.some(
        (paramRule) => paramRule.in === "query" && paramRule.name === name
      );
      if (!exists) {
        this.addError(`Unexpected query parameter '${name}' was provided.`);
      }
    }

    // Validate unexpected body params
    for (let name of Object.keys(body)) {
      const exists = ruleParameters.some(
        (paramRule) =>
          paramRule.in === "body" &&
          Object.keys(paramRule.schema.properties).includes(name)
      );
      if (!exists) {
        this.addError(`Unexpected body parameter '${name}' was provided.`);
      }
    }

    return new ValidationResult(this.errors);
  }

  validateQueryParameter(parameterRule, query) {
    const { name } = parameterRule;
    const value = query[name];

    if (name && !value) {
      this.addError(`'${name}' is required.`);
      return;
    }

    this.validateType(parameterRule, value);
  }

  validateBodyParameter(parameterRule, body) {
    const { schema } = parameterRule;
    if (
      schema &&
      schema.type === "object" &&
      (!body || typeof body !== "object")
    ) {
      this.addError("Request body must be an object.");
      return;
    }

    for (let [name, { type }] of Object.entries(schema.properties)) {
      const value = body[name];
      if (schema.required && schema.required.includes(name) && !value) {
        this.addError(`'${name}' is required.`);
        continue;
      }

      this.validateType({ name, type }, value);
    }
  }

  validateType(paramRule, value) {
    const { name, type, items } = paramRule;

    if (type === "boolean" && typeof value !== "boolean") {
      this.addError(`'${name}' must be of type 'boolean'.`);
    } else if (type === "string" && typeof value !== "string") {
      this.addError(`'${name}' must be of type 'string'.`);
    } else if (type === "integer") {
      const int = parseInt(value);
      if (isNaN(int) || !Number.isInteger(+value)) {
        this.addError(`'${name}' must be of type 'integer'.`);
      }
    } else if (type === "array") {
      const arrayType = items.type;
      if (!Array.isArray(value)) {
        this.addError(`'${name}' must be an array of type '${arrayType}'.`);
        return;
      }
      value.forEach((x, i) =>
        this.validateType({ name: `${name}[${i}]`, type: arrayType }, x)
      );
    }
  }

  addError(error) {
    this.errors.push(error);
  }
}

class ValidationResult {
  errors = [];

  get isValid() {
    this.errors.length === 0;
  }

  constructor(errors) {
    this.errors = errors || [];
  }
}
